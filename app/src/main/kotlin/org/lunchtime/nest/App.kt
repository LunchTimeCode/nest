/*
 * This source file was generated by the Gradle 'init' task
 */
package org.lunchtime.nest

import io.github.oshai.kotlinlogging.KotlinLogging
import kotlinx.coroutines.cancel
import kotlinx.coroutines.coroutineScope
import org.http4k.core.Filter
import org.http4k.core.HttpHandler
import org.http4k.core.Method
import org.http4k.core.Response
import org.http4k.core.Status
import org.http4k.routing.RoutingHttpHandler
import org.http4k.routing.bind
import org.http4k.routing.routes
import org.http4k.server.KtorCIO
import org.http4k.server.ServerConfig
import org.http4k.server.asServer
import org.lunchtime.nest.endpoints.ActionDecisionEndpoint
import org.lunchtime.nest.endpoints.ChatEndpoint
import org.lunchtime.nest.endpoints.TasksEndpoint
import kotlin.time.measureTimedValue

private const val DEFAULT_PORT = 9998
val serverPort by lazy { System.getenv("SERVER_PORT")?.toInt() ?: DEFAULT_PORT }

private val log = KotlinLogging.logger { }

suspend fun main() {
    coroutineScope {
        val runtime = ServerRuntime.KtorCIO
        log.info { "Server runtime: ${runtime.name}" }
        val appConfig = AppConfig.fromEnv()

        val server = buildApp(appConfig).asServer(runtime.config(serverPort)).start()

        log.info { "Listening on http://0.0.0.0:$serverPort" }

        server.block()

        cancel()
    }
}

@Suppress("LongMethod")
private fun buildApp(config: AppConfig): RoutingHttpHandler {
    val keyFilter = ApiKeyFilter(config.apiKey)
    return routes(
        routes(
            "healthz" bind Method.GET to { Response(Status.NO_CONTENT) },
            routes(
                "task" bind Method.POST to TasksEndpoint(config),
                "actions" bind Method.POST to ActionDecisionEndpoint(config),
                "chat" bind Method.POST to ChatEndpoint(config),
            ).withFilter(keyFilter),
        ).withBasePath("api"),
    ).withFilter(
        ResponseLogger,
    )
}

private enum class ServerRuntime(
    val config: (port: Int) -> ServerConfig,
) {
    KtorCIO(::KtorCIO),
}

object ResponseLogger : Filter {
    private val log = KotlinLogging.logger { }

    override fun invoke(next: HttpHandler): HttpHandler =
        { req ->
            val (resp, duration) = measureTimedValue { next(req) }
            val message = { "${req.method} ${req.uri} -> ${resp.status} $duration" }
            if (resp.status.let { it.redirection || it.successful || it.informational }) {
                log.debug(message)
            } else if (resp.status.clientError) {
                log.warn(message)
            } else {
                log.error(message)
            }
            resp
        }
}

class ApiKeyFilter(
    private val apiKey: String,
) : Filter {
    private val log = KotlinLogging.logger { }

    override fun invoke(next: HttpHandler): HttpHandler =
        { req ->
            val fromR = req.header("api-key")
            val fromE = apiKey

            if (fromR == fromE) {
                next(req)
            } else {
                log.warn { "Non authorized try: ${req.method} ${req.uri}" }
                Response(Status.UNAUTHORIZED)
            }
        }
}
